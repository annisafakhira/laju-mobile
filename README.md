# Tugas Individu
## Annisa Fakhira Cendekia - 3406354606

## Tugas 7
1. Jelaskan apa itu widget tree pada Flutter dan bagaimana hubungan parent-child (induk-anak) bekerja antar widget.
    Pada flutter semua komponennya adalah widget (semua elemen UI berbentuk widget), dari semua widget tersebut terbentuk widget tree yang merupakan struktur atau hierarki widget dengan hubungan parent-child dalam aplikasi Flutter. Sama seperti hubungan parent-child pada umumnya, parent dapat memiliki banyak child, tetapi child hanya punya satu parent. Parent akan mengatur child, tetapi child tidak dapat mengatur parent, parent memastikan bagaimana child ditempatkan atau . Sebagai contoh Column merupakan parent dari Text dan childnya adalah Text("Hello World") maka text akan disusun secara vertikal sesuai parent.

2. Sebutkan semua widget yang kamu gunakan dalam proyek ini dan jelaskan fungsinya.
    Terdapat beberapa widget yang digunakan dalam proyek ini, root widget untuk aplikasi adalah MyApp yang extends StatelessWidget di main.dart dan return MaterialApp yang menyediakan kerangka Material Design, tema, dan navigator, serta menetapkan MyHomePage sebagai home. MyHomePage sendiri menggunakan Scaffold untuk menyusun struktur dari pagenya dengan AppBar untuk judul. Dalam mengatur layoutnya terdapat Padding yang memberi jarak tepi, Column yang menyusun secara vertikal, Row yang menyusun secara horizontal, SizedBox yang memberi jarak antar widget, Center yang memusatkan konten, Container yang mengatur ukuran lebarnya. Tampilan untuk datanya dengan GridView yang menampilkan tiga tombol berwarna yang bisa diklik (ItemCard) dalam grid 3 kolom, serta InfoCard yang menggunakan Card sebagai kartu yang menampilkan data. Pada ItemCard digunakan Material penyedia konteks material & latar berwarna dengan sudut melengkung dan InkWell untuk mendeteksi dan efek ripple serta memanggil ScaffoldMessenger untuk menampilkan SnackBar saat diklik. Semua dibangun dengan widget dasar seperti Text untuk tulisan dan Icon untuk gambar.

3. Apa fungsi dari widget MaterialApp? Jelaskan mengapa widget ini sering digunakan sebagai widget root.
    MaterialApp adalah widget yang menyediakan inti Material Design untuk seluruh aplikasi, seperti ThemeData dan ColorScheme untuk memastikan widget di bawahnya memiliki tema yang konsisten, sistem navigasi dan routing sehingga bisa pindah layar, lokalisasi, dan mempermudah untuk memanggil SnackBar atau Dialog. Oleh karena itu, MaterialApp digunakan sebagai root widget agar dapat diwariskan dan diakses dari mana saja di dalam widget tree menggunakan BuildContext. Selain itu, MaterialApp juga menentukan home, widget pertama yang akan ditampilkan saat aplikasi berjalan.

4. Jelaskan perbedaan antara StatelessWidget dan StatefulWidget. Kapan kamu memilih salah satunya?
    Perbedaan utamanya StatelessWidget dan StatefulWidget adalah data yang bisa diubah, StatelessWidget adalah widget tanpa state internal yang sepenuhnya ditentukan oleh input dan hanya rebuild ketika parent memberi data baru. StatelessWidget cocok untuk tampilan statis seperti label, ikon, atau komponen presentasional murni. StatefulWidget memiliki objek State yang menyimpan data dinamis dengan method seperti initState, setState, dispose yang memungkinkan UI berubah saat interaksi user, async fetch, atau timer. useranya sendiri tergantung kerbutuhan, pilih StatelessWidget untuk UI yang tidak bergantung perubahan internal dan hanya membaca data dan pilih StatefulWidget jika ada interaksi yang mengubah tampilan.

5. Apa itu BuildContext dan mengapa penting di Flutter? Bagaimana userannya di metode build?
    BuildContext merupakan address sebuah widget di dalam widget tree serta penting karena BuildContext yang memberi akses ke ancestor sehingga dapat mencari data atau layanan dari ancestors di atasnya. Sebagai contoh Theme.of(context) untuk warna atau typography, ScaffoldMessenger.of(context) untuk SnackBar, Navigator.of(context) untuk pindah page, dan MediaQuery.of(context) untuk ukuran dan membuat UI responsif. Dalam metode build(BuildContext context), context diterima sebagai parameter dari Flutter dan digunakan untuk mengambil fungsionalitas yang diwariskan dengan memanggil method .of().

6. Jelaskan konsep "hot reload" di Flutter dan bagaimana bedanya dengan "hot restart".
    Konsep hot reload adalah fitur yang meng-inject perubahan ke Dart yang Virtual Machine-nya yang sedang berjalan, memanggil ulang build() pada widget yang terpengaruh, dan mempertahankan state sehingga dapat melihat perubahan UI secara instan. Sedangkan, hot restart menjalankan ulang aplikasi dari main(), menghapus seluruh state, dan membangun ulang widget tree dari awal sehingga lebih lambat dari hot reload. Perbedaan utamanya hot reload menjaga state dan hot restart akan reset state-nya. Dalam userannya, hot reload digunakan untuk perubahan lokal yang tidak mengubah inisialisasi global dan hot restart digunakan saat mengubah variabel global, konstruktor awal, atau logika yang butuh aplikasi reset dari kondisi awal.

## Tugas 8
1. Jelaskan perbedaan antara Navigator.push() dan Navigator.pushReplacement() pada Flutter. Dalam kasus apa sebaiknya masing-masing digunakan pada aplikasi Football Shop kamu?
    Pada Flutter, Navigator.push() dan Navigator.pushReplacement() sama sama digunakan untuk berpindah atau mengganti page. Perbedaan keduanya adalah Navigator.push() menambahkannya sedangkan Navigator.pushReplacement() itu menggantinya sehingga untuk Navigator.push() dapat kembali ke halaman sebelumnya karena kita hanya "menumpuk" tetapi untuk Navigator.pushReplacement() kita tidak dapat kembali karena kita sudah mengganti yang sebelumnya. userannya di aplikasi adalah ketika ingin Add Product dari ItemCard (di home page) cukup menggunakan push sehingga bisa kembali ke page sebelumnya (home page). Akan tetapi, untuk drawer menggunakan Navigator.pushReplacement() agar tidak salah page, contohnya ketika menekan home tetapi hanya back ke page sebelumnya bisa saja page sebelumnya bukan home sehingga untuk drawer diganti pagenya dengan page yang sesuai oleh Navigator.pushReplacement().

2. Bagaimana kamu memanfaatkan hierarchy widget seperti Scaffold, AppBar, dan Drawer untuk membangun struktur halaman yang konsisten di seluruh aplikasi?
    Dalam membangun struktur halaman yang konsisten di seluruh aplikasi Scaffold digunakan untuk kerangka halaman tempat elemen-elemen lain seperti AppBar dan Drawer berada. Sementara itu, AppBar digunakan untuk header sehingga judul atau nama halaman konsisten gayanya di seluruh aplikasi dan Drawer digunakan untuk mempermudah user berpindah halaman dan untuk setiap menu navigasi akan berpindah ke halaman yang benar serta konsisten.

3. Dalam konteks desain antarmuka, apa kelebihan menggunakan layout widget seperti Padding, SingleChildScrollView, dan ListView saat menampilkan elemen-elemen form? Berikan contoh userannya dari aplikasi kamu.
    Menggunakan layout widget dalam desain akan membuat tampilan form jadi lebih rapi dan nyaman untuk dilihat. Pada aplikasi padding memberi jarak agar setiap field form tidak mepet ke tepi layar. SingleChildScrollView membuat form yang panjang dapat discroll ke bawah sehingga halaman tidak error dan user tetap bisa melihat semua input. Sementara ListView digunakan untuk menampilkan item seperti daftar menu “Home” dan “Add Product” dapat discroll jika menu terlalu banyak.

4. Bagaimana kamu menyesuaikan warna tema agar aplikasi Football Shop memiliki identitas visual yang konsisten dengan brand toko?
    Untuk saat ini saya masih mengikuti warna pada tugas sebelumnya tetapi untuk penyesuaian warna dapat dilakukan dengan mengubah warna pada elemen-elemen penting seperti AppBar, ItemCard, dan Drawer. Dengan menggunakan warna yang sama di seluruh halaman maka aplikasi Football Shop akan memiliki identitas visual yang konsisten.

## Tugas 9
1. Jelaskan mengapa kita perlu membuat model Dart saat mengambil/mengirim data JSON? Apa konsekuensinya jika langsung memetakan Map<String, dynamic> tanpa model (terkait validasi tipe, null-safety, maintainability)?
    Membuat model Dart saat mengambil atau mengirim data JSON penting karena Dart adalah bahasa strongly typed dan null-safe. Model Dart membuat data dari Map<String, dynamic> menjadi objek Dart sehingga terdapat struktur yang jelas, validasi tipe data setiap field, serta null-safety. Sementara jika langsung memakai Map<String, dynamic> tanpa model maka aplikasi akan rentan terhadap runtime error yang disebabkan oleh tipe data tidak sesuai ataupun return null. Selain itu, kode juga menjadi sulit dibaca dan lebih susah dimaintain, terutama ketika data bertambah kompleks atau digunakan di banyak bagian aplikasi karena jika terjadi perubahan maka harus diubah di puluhan tempat di seluruh kode, bukan hanya terpusat di satu file model saja.

2.  Apa fungsi package http dan CookieRequest dalam tugas ini? Jelaskan perbedaan peran http vs CookieRequest.
    Package http berfungsi untuk melakukan request HTTP biasa yang mengirim dan menerima data tanpa ketentuan khusus, sedangkan CookieRequest dibuat khusus untuk berkomunikasi dengan backend Django yang menggunakan session based authentication dengan otomatis menyimpan dan mengirim cookie sehingga request yang membutuhkan login required dapat berjalan tanpa harus mengatur cookie secara manual.

3. Jelaskan mengapa instance CookieRequest perlu untuk dibagikan ke semua komponen di aplikasi Flutter.
    Instance CookieRequest perlu dibagikan ke semua komponen aplikasi Flutter karena menyimpan status autentikasi user, termasuk sessionid yang diberikan Django setelah login. Jika setiap komponen membuat instance baru, maka cookie tidak diingat dan komponen lain tidak tahu bahwa user sudah login. Sementara jika membagikan satu instance CookieRequest, seluruh widget dalam aplikasi akan mengakses status login yang sama sehingga dapat melakukan request terautentikasi dan mempertahankan sesi secara konsisten.

4. Jelaskan konfigurasi konektivitas yang diperlukan agar Flutter dapat berkomunikasi dengan Django. Mengapa kita perlu menambahkan 10.0.2.2 pada ALLOWED_HOSTS, mengaktifkan CORS dan pengaturan SameSite/cookie, dan menambahkan izin akses internet di Android? Apa yang akan terjadi jika konfigurasi tersebut tidak dilakukan dengan benar?
    Untuk membuat Flutter dapat berkomunikasi dengan Django, beberapa konfigurasi konektivitas terdapat beberapa konfigurasi konektivitas yang diperlukan. Pertama, Alamat 10.0.2.2 harus ditambahkan ke ALLOWED_HOSTS, jika tidak ditambahkan maka Django akan menolak request akses. Django juga perlu mengatur CORS dan mengatur SameSite untuk cookie agar Flutter dapat mengirim request dan menerima cookie sesi login. Jika CORS tidak diatur, Django akan memblokir request dari Flutter. Selain itu, AndroidManifest.xml juga perlu diadjust agar diizinkan oleh OS Android untuk membuat koneksi jaringan apa pun karena aplikasi Android by default tidak memiliki izin jaringan, tanpa izin tersebut aplikasi tidak dapat melakukan apa pun.

5. Jelaskan mekanisme pengiriman data mulai dari input hingga dapat ditampilkan pada Flutter.
    Mekanisme pengiriman data dari input hingga ditampilkan di Flutter berlangsung melalui beberapa tahap yang berurutan dan dimulai dengan pengisian form atau melakukan aksi di Flutter, lalu data tersebut dikumpulkan dan divalidasi melalui widget seperti TextFormField dan Form. Setelah validasi berhasil, Flutter mengirim data tersebut ke endpoint API Django dalam format JSON melalui request HTTP dengan CookieRequest atau http. Django kemudian menerima request dan membaca request.body, lalu memprosesnya dan mengembalikan respons JSON. Flutter await response tersebut, lalu data JSON didecode dan dikonversi menjadi model Dart agar type-safe. Data dari model kemudian diolah atau disimpan dalam state yang memicu Flutter rebuild UI untuk menampilkan data yang diterima.

6. Jelaskan mekanisme autentikasi dari login, register, hingga logout. Mulai dari input data akun pada Flutter ke Django hingga selesainya proses autentikasi oleh Django dan tampilnya menu pada Flutter.
   Mekanisme autentikasi dimulai dari proses register, di mana Flutter mengambil input user melalui form, memvalidasi datanya, dan mengirimkannya ke Django dalam bentuk JSON. Django memproses request tersebut, memvalidasi data akun, lalu membuat user baru. Setelah itu, user dapat login dengan memasukkan username dan password di Flutter, kredensial dikirim melalui CookieRequest ke endpoint login Django yang kemudian memverifikasi data menggunakan sistem autentikasi bawaan Django. Jika valid, Django mengirimkan respons sukses beserta session cookie (sessionid) dan CookieRequest otomatis menyimpannya sehingga setiap request selanjutnya ke Django mengirimkan cookie ini dan user dikenali tanpa login ulang. Setelah login berhasil, Flutter menavigasikan user ke halaman menu utama yang hanya dapat diakses oleh authenticated user. Proses logout dilakukan dengan mengirim request ke endpoint logout Django, yang menghapus session pada server dan CookieRequest menghapus cookie lokal sehingga status login di Flutter hilang dan user diarahkan kembali ke halaman login.

7. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step! (bukan hanya sekadar mengikuti tutorial).
   Pertama, adjust Django (mengatur ALLOWED_HOSTS, CORS, dan cookie) agar Django terkoneksi dengan Flutter dan pastikan proyek sudah jalan dan endpoint JSON bisa diakses. Lalu menambahkan beberapa fungsi untuk menerima request dan mengirim data ke Flutter. Kemudian buat file-file baru di Flutter untuk autentikasi seperti register yang berupa form TextFormField untuk username, password, dan confirm password lalu ketika tombol Register diclick maka form akan divalidasi dan datanya dikirim ke endpoint register Django, dan jika berhasil aku tampilkan SnackBar dan arahkan user ke halaman login. Lalu, login di Flutter dibuat dengan memanggil request.login(".../auth/login/", {...}) dari package pbp_django_auth sehingga kalau kredensial benar, session cookie dari Django tersimpan di CookieRequest dan pindah ke MyHomePage. Tak lupa untuk membuat sistem autentikasi terintegrasi, di main.dart bungkus aplikasi dengan Provider dan  berikan satu instance CookieRequest ke seluruh widget, lalu pada fitur yang butuh login gunakan instance. Untuk logout, menggunakan request.logout(".../auth/logout/") dan jika berhasil arahkan kembali ke LoginPage. Tak hanya itu, model kustom Dart juga perlu dibuat untuk ProductEntry yang strukturnya persis mengikuti model Django, dilengkapi fromJson dan toJson, sehingga setiap respons JSON dari Django bisa langsung dikonversi menjadi objek yang aman tipe datanya. Kemudian untuk melihat daftar produk dibuat page lagi dengan ProductEntryListPage yang melakukan request.get(".../json/"), mengubah hasilnya menjadi List<ProductEntry>, lalu menampilkannya dengan ListView.builder dan ProductEntryCard yang menampilkan name, price, potongan description, thumbnail lewat Image.network (via proxy), category, dan label “Featured” jika is_featured bernilai true. Lalu untuk detail produk menggunakan ProductDetailPage yang menerima satu objek ProductEntry dari onTap di kartu dan menampilkan semua atribut serta thumbnaik di atasnya dan menyediakan tombol back bawaan AppBar untuk kembali ke daftar. Terakhir, untuk filter item milik user yang login, tambahkan fungsi  di Django yang melakukan Product.objects.filter(user=request.user) dan mengembalikan JSON berisi hanya produk milik user tersebut, lalu di Flutter dibuay MyProductListPage yang memanggil endpoint ".../json/my-products/" dan menampilkannya dengan pola yang sama seperti halaman All Products, sehingga halaman ini hanya berisi produk yang ditambahkan oleh akun yang sedang login.